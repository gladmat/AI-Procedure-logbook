Absolutely — here is the **complete Patch 3 package**, written as **step‑by‑step Replit Agent instructions**, in the same format as before.

---

# ✅ REPLIT AGENT INSTRUCTIONS — PATCH 3 (E2EE Scaffolding)

**Objective:** Add end‑to‑end encryption scaffolding (device keys, case key wrapping, key registry API).  
This does **not** yet implement team sharing UI or case sync; it prepares the crypto and server plumbing safely.

---

## **Step 1 — Add dependency**

Run:

```bash
npm install @noble/curves
```

This will update `package.json` and `package-lock.json` automatically.

---

## **Step 2 — Create new crypto helper file**

Create file:  
`client/lib/e2ee.ts`

Paste the full contents below:

```ts
import { Platform } from "react-native";
import * as SecureStore from "expo-secure-store";
import AsyncStorage from "@react-native-async-storage/async-storage";
import * as Random from "expo-random";
import { x25519 } from "@noble/curves/ed25519";
import { hkdf } from "@noble/hashes/hkdf";
import { sha256 } from "@noble/hashes/sha256";
import { xchacha20poly1305 } from "@noble/ciphers/chacha";
import {
  bytesToHex,
  hexToBytes,
  utf8ToBytes,
  bytesToUtf8,
} from "@noble/hashes/utils";

const DEVICE_ID_KEY = "@surgical_logbook_device_id";
const DEVICE_PRIVATE_KEY = "@surgical_logbook_device_private_key";
const NONCE_BYTES = 24;
const KEY_BYTES = 32;
const CASE_KEY_CONTEXT = "surgical-logbook-case-key";

export interface PublicKeyBundle {
  version: 1;
  deviceId: string;
  publicKey: string;
  label?: string;
}

export interface CaseKeyEnvelope {
  version: 1;
  senderDeviceId: string;
  senderPublicKey: string;
  recipientPublicKey: string;
  nonce: string;
  cipher: string;
  createdAt: string;
}

async function getSecret(key: string): Promise<string | null> {
  if (Platform.OS === "web") {
    return AsyncStorage.getItem(key);
  }
  return SecureStore.getItemAsync(key);
}

async function setSecret(key: string, value: string): Promise<void> {
  if (Platform.OS === "web") {
    await AsyncStorage.setItem(key, value);
    return;
  }
  await SecureStore.setItemAsync(key, value);
}

async function getOrCreateDeviceId(): Promise<string> {
  const existing = await getSecret(DEVICE_ID_KEY);
  if (existing) return existing;

  const id = bytesToHex(await Random.getRandomBytesAsync(16));
  await setSecret(DEVICE_ID_KEY, id);
  return id;
}

async function getOrCreateDevicePrivateKeyHex(): Promise<string> {
  const existing = await getSecret(DEVICE_PRIVATE_KEY);
  if (existing) return existing;

  const priv = bytesToHex(await Random.getRandomBytesAsync(KEY_BYTES));
  await setSecret(DEVICE_PRIVATE_KEY, priv);
  return priv;
}

async function getDeviceKeyPair(): Promise<{
  deviceId: string;
  privateKey: string;
  publicKey: string;
}> {
  const deviceId = await getOrCreateDeviceId();
  const privateKey = await getOrCreateDevicePrivateKeyHex();
  const publicKey = bytesToHex(
    x25519.getPublicKey(hexToBytes(privateKey)),
  );

  return { deviceId, privateKey, publicKey };
}

function deriveSharedKey(
  privateKeyHex: string,
  publicKeyHex: string,
): Uint8Array {
  const sharedSecret = x25519.getSharedSecret(
    hexToBytes(privateKeyHex),
    hexToBytes(publicKeyHex),
  );
  return hkdf(sha256, sharedSecret, undefined, utf8ToBytes(CASE_KEY_CONTEXT), KEY_BYTES);
}

export async function getOrCreateDeviceIdentity(): Promise<{
  deviceId: string;
  publicKey: string;
}> {
  const { deviceId, publicKey } = await getDeviceKeyPair();
  return { deviceId, publicKey };
}

export async function exportPublicKeyBundle(label?: string): Promise<string> {
  const { deviceId, publicKey } = await getDeviceKeyPair();
  const bundle: PublicKeyBundle = {
    version: 1,
    deviceId,
    publicKey,
    label,
  };
  return JSON.stringify(bundle);
}

export function parsePublicKeyBundle(raw: string): PublicKeyBundle | null {
  try {
    const parsed = JSON.parse(raw) as PublicKeyBundle;
    if (parsed.version !== 1) return null;
    if (!parsed.deviceId || !parsed.publicKey) return null;
    return parsed;
  } catch {
    return null;
  }
}

export async function generateCaseKeyHex(): Promise<string> {
  return bytesToHex(await Random.getRandomBytesAsync(KEY_BYTES));
}

export async function encryptPayloadWithCaseKey(
  plaintext: string,
  caseKeyHex: string,
): Promise<string> {
  const nonce = await Random.getRandomBytesAsync(NONCE_BYTES);
  const cipher = xchacha20poly1305(hexToBytes(caseKeyHex));
  const ciphertext = cipher.encrypt(nonce, utf8ToBytes(plaintext));

  return `case:v1:${bytesToHex(nonce)}:${bytesToHex(ciphertext)}`;
}

export function decryptPayloadWithCaseKey(
  envelope: string,
  caseKeyHex: string,
): string {
  if (!envelope.startsWith("case:v1:")) return envelope;

  const parts = envelope.split(":");
  if (parts.length !== 4) return envelope;

  const nonceHex = parts[2];
  const cipherHex = parts[3];

  const cipher = xchacha20poly1305(hexToBytes(caseKeyHex));
  const plaintextBytes = cipher.decrypt(
    hexToBytes(nonceHex),
    hexToBytes(cipherHex),
  );
  return bytesToUtf8(plaintextBytes);
}

export async function wrapCaseKeyForRecipient(
  caseKeyHex: string,
  recipientPublicKeyHex: string,
): Promise<CaseKeyEnvelope> {
  const { deviceId, privateKey, publicKey } = await getDeviceKeyPair();
  const sharedKey = deriveSharedKey(privateKey, recipientPublicKeyHex);
  const nonce = await Random.getRandomBytesAsync(NONCE_BYTES);
  const cipher = xchacha20poly1305(sharedKey);
  const ciphertext = cipher.encrypt(nonce, hexToBytes(caseKeyHex));

  return {
    version: 1,
    senderDeviceId: deviceId,
    senderPublicKey: publicKey,
    recipientPublicKey: recipientPublicKeyHex,
    nonce: bytesToHex(nonce),
    cipher: bytesToHex(ciphertext),
    createdAt: new Date().toISOString(),
  };
}

export async function unwrapCaseKeyEnvelope(
  envelope: CaseKeyEnvelope,
): Promise<string> {
  const { privateKey } = await getDeviceKeyPair();
  const sharedKey = deriveSharedKey(privateKey, envelope.senderPublicKey);

  const cipher = xchacha20poly1305(sharedKey);
  const caseKeyBytes = cipher.decrypt(
    hexToBytes(envelope.nonce),
    hexToBytes(envelope.cipher),
  );

  return bytesToHex(caseKeyBytes);
}
```

---

## **Step 3 — Add device key table to schema**

Edit:  
`shared/schema.ts`

1. Update imports at top:

```ts
import { pgTable, text, varchar, boolean, integer, decimal, timestamp, serial, uniqueIndex } from "drizzle-orm/pg-core";
```

2. Add the new table **after `users` table**:

```ts
export const userDeviceKeys = pgTable(
  "user_device_keys",
  {
    id: varchar("id")
      .primaryKey()
      .default(sql`gen_random_uuid()`),
    userId: varchar("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    deviceId: varchar("device_id", { length: 64 }).notNull(),
    publicKey: text("public_key").notNull(),
    label: text("label"),
    createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
    lastSeenAt: timestamp("last_seen_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
    revokedAt: timestamp("revoked_at"),
  },
  (t) => ({
    userDeviceUnique: uniqueIndex("user_device_keys_user_device_idx").on(
      t.userId,
      t.deviceId,
    ),
  }),
);

export const insertUserDeviceKeySchema = createInsertSchema(userDeviceKeys).omit({
  id: true,
  createdAt: true,
  lastSeenAt: true,
  revokedAt: true,
});

export type UserDeviceKey = typeof userDeviceKeys.$inferSelect;
export type InsertUserDeviceKey = z.infer<typeof insertUserDeviceKeySchema>;
```

---

## **Step 4 — Add storage methods**

Edit:  
`server/storage.ts`

1. Update imports:
```ts
import {
  ...
  userDeviceKeys, type UserDeviceKey
} from "@shared/schema";
import { eq, and, ilike, sql, lt, isNull } from "drizzle-orm";
```

2. Add to `IStorage`:
```ts
getUserDeviceKeys(userId: string): Promise<UserDeviceKey[]>;
upsertUserDeviceKey(userId: string, deviceId: string, publicKey: string, label?: string | null): Promise<UserDeviceKey>;
revokeUserDeviceKey(userId: string, deviceId: string): Promise<boolean>;
```

3. Add implementations inside `DatabaseStorage`:

```ts
async getUserDeviceKeys(userId: string): Promise<UserDeviceKey[]> {
  return db
    .select()
    .from(userDeviceKeys)
    .where(and(eq(userDeviceKeys.userId, userId), isNull(userDeviceKeys.revokedAt)));
}

async upsertUserDeviceKey(userId: string, deviceId: string, publicKey: string, label?: string | null): Promise<UserDeviceKey> {
  const [existing] = await db
    .select()
    .from(userDeviceKeys)
    .where(and(eq(userDeviceKeys.userId, userId), eq(userDeviceKeys.deviceId, deviceId)));

  if (existing) {
    const [updated] = await db
      .update(userDeviceKeys)
      .set({
        publicKey,
        label: label ?? existing.label ?? null,
        lastSeenAt: new Date(),
        revokedAt: null,
      })
      .where(eq(userDeviceKeys.id, existing.id))
      .returning();
    return updated;
  }

  const [created] = await db
    .insert(userDeviceKeys)
    .values({ userId, deviceId, publicKey, label: label ?? null })
    .returning();
  return created;
}

async revokeUserDeviceKey(userId: string, deviceId: string): Promise<boolean> {
  await db
    .update(userDeviceKeys)
    .set({ revokedAt: new Date() })
    .where(and(eq(userDeviceKeys.userId, userId), eq(userDeviceKeys.deviceId, deviceId)));
  return true;
}
```

---

## **Step 5 — Add API endpoints**

Edit:  
`server/routes.ts`

1. Add these endpoints after auth routes:

```ts
  app.post("/api/keys/device", authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const { deviceId, publicKey, label } = req.body;

      if (!deviceId || !publicKey) {
        return res.status(400).json({ error: "deviceId and publicKey required" });
      }

      if (typeof deviceId !== "string" || typeof publicKey !== "string") {
        return res.status(400).json({ error: "Invalid payload" });
      }

      const key = await storage.upsertUserDeviceKey(
        req.userId!,
        deviceId,
        publicKey,
        typeof label === "string" ? label : null
      );

      res.json({ success: true, keyId: key.id });
    } catch (error) {
      console.error("Device key upsert error:", error);
      res.status(500).json({ error: "Failed to register device key" });
    }
  });

  app.get("/api/keys/me", authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const keys = await storage.getUserDeviceKeys(req.userId!);
      res.json(keys);
    } catch (error) {
      console.error("Device key fetch error:", error);
      res.status(500).json({ error: "Failed to fetch device keys" });
    }
  });

  app.post("/api/keys/revoke", authenticateToken, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const { deviceId } = req.body;
      if (!deviceId || typeof deviceId !== "string") {
        return res.status(400).json({ error: "deviceId required" });
      }

      await storage.revokeUserDeviceKey(req.userId!, deviceId);
      res.json({ success: true });
    } catch (error) {
      console.error("Device key revoke error:", error);
      res.status(500).json({ error: "Failed to revoke device key" });
    }
  });
```

---

## **Step 6 — Add client API call**

Edit:  
`client/lib/auth.ts`

Add this function near the bottom:

```ts
export async function registerDeviceKey(
  deviceId: string,
  publicKey: string,
  label?: string
): Promise<void> {
  const res = await authFetch("/api/keys/device", {
    method: "POST",
    body: JSON.stringify({ deviceId, publicKey, label }),
  });

  if (!res.ok) {
    const error = await res.json();
    throw new Error(error.error || "Failed to register device key");
  }
}
```

---

## **Step 7 — Register key on login/refresh**

Edit:  
`client/contexts/AuthContext.tsx`

1. Add imports at top:

```ts
import { Platform } from "react-native";
import { getOrCreateDeviceIdentity } from "@/lib/e2ee";
import { registerDeviceKey } from "@/lib/auth";
```

2. Inside `refreshUser`, after setting user/profile:

```ts
      if (data) {
        try {
          const { deviceId, publicKey } = await getOrCreateDeviceIdentity();
          await registerDeviceKey(deviceId, publicKey, Platform.OS);
        } catch (error) {
          console.warn("Device key registration failed:", error);
        }
      }
```

3. Inside `login` and `signup`, after `setUser(...)`:

```ts
    try {
      const { deviceId, publicKey } = await getOrCreateDeviceIdentity();
      await registerDeviceKey(deviceId, publicKey, Platform.OS);
    } catch (error) {
      console.warn("Device key registration failed:", error);
    }
```

---

## **Step 8 — Apply DB migration**

Run:

```bash
npm run db:push
```

---

# ✅ Result

You now have:

- Per‑device X25519 keys stored on device  
- Public key registry in server DB  
- Safe key rotation + revocation  
- Case key wrapping and encrypted payload support  

This is the cryptographic foundation for E2EE team sharing.

---

If you want, I can now draft **Patch 4** for actual team sharing:
- case envelope storage
- encrypted case uploads
- member key rotation
- share / revoke flows